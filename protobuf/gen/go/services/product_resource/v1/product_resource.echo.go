// Code generated by protoc-gen-fasthttp. DO NOT EDIT.
package product_resourcev1

import (
	"fmt"

	"github.com/labstack/echo/v4"
	"github.com/rsfreitas/go-pocket-utils/response"
)

type echoServerRoutesWrapper struct {
	ServiceName string
	Handler     ProductResourceServiceServer
	AuthHandler AuthHandler
	Logger      Logger
}

func (w *echoServerRoutesWrapper) CreateProduct(c echo.Context) error {
	ctx := c.Request().Context()
	res := response.NewFromEcho(c, &response.Options{
		ServiceName: w.ServiceName,
	})

	// Common attributes to print in each log message inside the handler.
	logAttributes := map[string]interface{}{
		"request.endpoint":  string(c.Request().URL.Path),
		"request.client_ip": c.Request().RemoteAddr,
		"request.method":    string(c.Request().Method),
	}

	w.Logger.Infof(ctx, "request received", logAttributes)

	if w.AuthHandler != nil {
		if err := w.AuthHandler(ctx); err != nil {
			logAttributes["error.message"] = err.Error()
			w.Logger.Errorf(ctx, "authentication error", logAttributes)
			return res.ForwardAuthenticationError(err)
		}
	}

	input, err := newCreateProductRequestFromEchoRequest(c)
	if err != nil {
		logAttributes["error.message"] = err.Error()
		w.Logger.Errorf(ctx, "request input error", logAttributes)
		return res.ForwardError(err)
	}

	ctx = response.AppendResponseToContext(ctx, res)
	out, err := w.Handler.CreateProduct(ctx, input.ProtoResponse())
	if err != nil {
		// Just a warning here. We don't need to log the error message
		// here simply because the error returned by the handler should
		// use the framework.Error API which already writes a message
		// into it.
		return res.ForwardError(err)
	}

	w.Logger.Infof(ctx, "request successfully handled", logAttributes)
	return res.ForwardSuccess(out)
}

// newCreateProductRequestFromFasthttpRequest creates a CreateProductRequest object by filling it with values
// from the request data. It handles all possible arguments here: path, query
// and body.
func newCreateProductRequestFromEchoRequest(ctx echo.Context) (*CreateProductRequestModel, error) {
	c := &CreateProductRequestModel{}

	// Starts by parsing the request body into the whole structure. If we have
	// a field that's not in the body and the user passes it here with a wrong
	// JSON value, it will return an error.
	//
	// Then we parse all other fields from different location, if needed. Like
	// path, query or header parameters. And, before parsing each one of them,
	// we zero them to make sure that they are uninitialized.

	if err := ctx.Bind(c); err != nil {
		return nil, fmt.Errorf("body: %w", err)
	}

	return c, nil
}

func (w *echoServerRoutesWrapper) GetProductByID(c echo.Context) error {
	ctx := c.Request().Context()
	res := response.NewFromEcho(c, &response.Options{
		ServiceName: w.ServiceName,
	})

	// Common attributes to print in each log message inside the handler.
	logAttributes := map[string]interface{}{
		"request.endpoint":  string(c.Request().URL.Path),
		"request.client_ip": c.Request().RemoteAddr,
		"request.method":    string(c.Request().Method),
	}

	w.Logger.Infof(ctx, "request received", logAttributes)

	if w.AuthHandler != nil {
		if err := w.AuthHandler(ctx); err != nil {
			logAttributes["error.message"] = err.Error()
			w.Logger.Errorf(ctx, "authentication error", logAttributes)
			return res.ForwardAuthenticationError(err)
		}
	}

	input, err := newGetProductByIDRequestFromEchoRequest(c)
	if err != nil {
		logAttributes["error.message"] = err.Error()
		w.Logger.Errorf(ctx, "request input error", logAttributes)
		return res.ForwardError(err)
	}

	ctx = response.AppendResponseToContext(ctx, res)
	out, err := w.Handler.GetProductByID(ctx, input.ProtoResponse())
	if err != nil {
		// Just a warning here. We don't need to log the error message
		// here simply because the error returned by the handler should
		// use the framework.Error API which already writes a message
		// into it.
		return res.ForwardError(err)
	}

	w.Logger.Infof(ctx, "request successfully handled", logAttributes)
	return res.ForwardSuccess(out)
}

// newGetProductByIDRequestFromFasthttpRequest creates a GetProductByIDRequest object by filling it with values
// from the request data. It handles all possible arguments here: path, query
// and body.
func newGetProductByIDRequestFromEchoRequest(ctx echo.Context) (*GetProductByIDRequestModel, error) {
	g := &GetProductByIDRequestModel{}

	// Starts by parsing the request body into the whole structure. If we have
	// a field that's not in the body and the user passes it here with a wrong
	// JSON value, it will return an error.
	//
	// Then we parse all other fields from different location, if needed. Like
	// path, query or header parameters. And, before parsing each one of them,
	// we zero them to make sure that they are uninitialized.

	response.Zero(&g.Id)
	if v := ctx.Param("id"); v != "" {
		if err := response.Decode([]byte(v), &g.Id); err != nil {
			return nil, fmt.Errorf("id@path: %w", err)
		}
	}

	response.Zero(&g.ReturnDeleted)
	if value := ctx.QueryParam("return_deleted"); value != "" {
		if err := response.Decode([]byte(value), &g.ReturnDeleted); err != nil {
			return nil, fmt.Errorf("return_deleted@query: %w", err)
		}
	}

	return g, nil
}

func (w *echoServerRoutesWrapper) UpdateProduct(c echo.Context) error {
	ctx := c.Request().Context()
	res := response.NewFromEcho(c, &response.Options{
		ServiceName: w.ServiceName,
	})

	// Common attributes to print in each log message inside the handler.
	logAttributes := map[string]interface{}{
		"request.endpoint":  string(c.Request().URL.Path),
		"request.client_ip": c.Request().RemoteAddr,
		"request.method":    string(c.Request().Method),
	}

	w.Logger.Infof(ctx, "request received", logAttributes)

	if w.AuthHandler != nil {
		if err := w.AuthHandler(ctx); err != nil {
			logAttributes["error.message"] = err.Error()
			w.Logger.Errorf(ctx, "authentication error", logAttributes)
			return res.ForwardAuthenticationError(err)
		}
	}

	input, err := newUpdateProductRequestFromEchoRequest(c)
	if err != nil {
		logAttributes["error.message"] = err.Error()
		w.Logger.Errorf(ctx, "request input error", logAttributes)
		return res.ForwardError(err)
	}

	ctx = response.AppendResponseToContext(ctx, res)
	out, err := w.Handler.UpdateProduct(ctx, input.ProtoResponse())
	if err != nil {
		// Just a warning here. We don't need to log the error message
		// here simply because the error returned by the handler should
		// use the framework.Error API which already writes a message
		// into it.
		return res.ForwardError(err)
	}

	w.Logger.Infof(ctx, "request successfully handled", logAttributes)
	return res.ForwardSuccess(out)
}

// newUpdateProductRequestFromFasthttpRequest creates a UpdateProductRequest object by filling it with values
// from the request data. It handles all possible arguments here: path, query
// and body.
func newUpdateProductRequestFromEchoRequest(ctx echo.Context) (*UpdateProductRequestModel, error) {
	u := &UpdateProductRequestModel{}

	// Starts by parsing the request body into the whole structure. If we have
	// a field that's not in the body and the user passes it here with a wrong
	// JSON value, it will return an error.
	//
	// Then we parse all other fields from different location, if needed. Like
	// path, query or header parameters. And, before parsing each one of them,
	// we zero them to make sure that they are uninitialized.

	if err := ctx.Bind(u); err != nil {
		return nil, fmt.Errorf("body: %w", err)
	}

	response.Zero(&u.Id)
	if v := ctx.Param("id"); v != "" {
		if err := response.Decode([]byte(v), &u.Id); err != nil {
			return nil, fmt.Errorf("id@path: %w", err)
		}
	}

	return u, nil
}

func (w *echoServerRoutesWrapper) DeleteProduct(c echo.Context) error {
	ctx := c.Request().Context()
	res := response.NewFromEcho(c, &response.Options{
		ServiceName: w.ServiceName,
	})

	// Common attributes to print in each log message inside the handler.
	logAttributes := map[string]interface{}{
		"request.endpoint":  string(c.Request().URL.Path),
		"request.client_ip": c.Request().RemoteAddr,
		"request.method":    string(c.Request().Method),
	}

	w.Logger.Infof(ctx, "request received", logAttributes)

	if w.AuthHandler != nil {
		if err := w.AuthHandler(ctx); err != nil {
			logAttributes["error.message"] = err.Error()
			w.Logger.Errorf(ctx, "authentication error", logAttributes)
			return res.ForwardAuthenticationError(err)
		}
	}

	input, err := newDeleteProductRequestFromEchoRequest(c)
	if err != nil {
		logAttributes["error.message"] = err.Error()
		w.Logger.Errorf(ctx, "request input error", logAttributes)
		return res.ForwardError(err)
	}

	ctx = response.AppendResponseToContext(ctx, res)
	out, err := w.Handler.DeleteProduct(ctx, input.ProtoResponse())
	if err != nil {
		// Just a warning here. We don't need to log the error message
		// here simply because the error returned by the handler should
		// use the framework.Error API which already writes a message
		// into it.
		return res.ForwardError(err)
	}

	w.Logger.Infof(ctx, "request successfully handled", logAttributes)
	return res.ForwardSuccess(out)
}

// newDeleteProductRequestFromFasthttpRequest creates a DeleteProductRequest object by filling it with values
// from the request data. It handles all possible arguments here: path, query
// and body.
func newDeleteProductRequestFromEchoRequest(ctx echo.Context) (*DeleteProductRequestModel, error) {
	d := &DeleteProductRequestModel{}

	// Starts by parsing the request body into the whole structure. If we have
	// a field that's not in the body and the user passes it here with a wrong
	// JSON value, it will return an error.
	//
	// Then we parse all other fields from different location, if needed. Like
	// path, query or header parameters. And, before parsing each one of them,
	// we zero them to make sure that they are uninitialized.

	response.Zero(&d.Id)
	if v := ctx.Param("id"); v != "" {
		if err := response.Decode([]byte(v), &d.Id); err != nil {
			return nil, fmt.Errorf("id@path: %w", err)
		}
	}

	return d, nil
}
