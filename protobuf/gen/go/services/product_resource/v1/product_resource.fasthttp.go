// Code generated by protoc-gen-fasthttp. DO NOT EDIT.
package product_resourcev1

import (
	"errors"
	"encoding/json"
	"fmt"

	"github.com/valyala/fasthttp"
	"github.com/rsfreitas/go-pocket-utils/response"
)

const (
	emptyBodyError = "cannot handle an empty body"
)

type fasthttpServerRoutesWrapper struct {
	ServiceName string
	Handler     ProductResourceServiceServer
	AuthHandler AuthHandler
	Logger      Logger
}

func (w *fasthttpServerRoutesWrapper) CreateProduct(ctx *fasthttp.RequestCtx) {
	res := response.NewFromFasthttp(ctx, &response.Options{
		ServiceName: w.ServiceName,
	})

	// Common attributes to print in each log message inside the handler.
	logAttributes := map[string]interface{}{
		"request.endpoint":  string(ctx.RequestURI()),
		"request.client_ip": ctx.RemoteIP(),
		"request.method":    string(ctx.Method()),
	}

	w.Logger.Infof(ctx, "request received", logAttributes)

	if w.AuthHandler != nil {
		if err := w.AuthHandler(ctx); err != nil {
			_ = res.ForwardAuthenticationError(err)
			logAttributes["error.message"] = err.Error()
			w.Logger.Errorf(ctx, "authentication error", logAttributes)
			return
		}
	}

	input, err := newCreateProductRequestFromFasthttpRequest(ctx)
	if err != nil {
		_ = res.ForwardError(err)
		logAttributes["error.message"] = err.Error()
		w.Logger.Errorf(ctx, "request input error", logAttributes)
		return
	}

	out, err := w.Handler.CreateProduct(ctx, input.ProtoResponse())
	if err != nil {
		_ = res.ForwardError(err)

		// Just a warning here. We don't need to log the error message
		// here simply because the error returned by the handler should
		// use the framework.Error API which already writes a message
		// into it.
		return
	}

	w.Logger.Infof(ctx, "request successfully handled", logAttributes)
	_ = res.ForwardSuccess(out)
}

//
// ///////////////////// CreateProduct //////////////////////
//

// newCreateProductRequestFromFasthttpRequest creates a CreateProductRequest object by filling it with values
// from the request data. It handles all possible arguments here: path, query
// and body.
func newCreateProductRequestFromFasthttpRequest(ctx *fasthttp.RequestCtx) (*CreateProductRequestModel, error) {
	c := &CreateProductRequestModel{}

	// Starts by parsing the request body into the whole structure. If we have
	// a field that's not in the body and the user passes it here with a wrong
	// JSON value, it will return an error.
	//
	// Then we parse all other fields from different location, if needed. Like
	// path, query or header parameters. And, before parsing each one of them,
	// we zero them to make sure that they are uninitialized.

	if len(ctx.PostBody()) == 0 {
		return nil, errors.New(emptyBodyError)
	}

	if err := json.Unmarshal(ctx.PostBody(), c); err != nil {
		return nil, fmt.Errorf("body: %w", err)
	}

	return c, nil
}

func (w *fasthttpServerRoutesWrapper) GetProductByID(ctx *fasthttp.RequestCtx) {
	res := response.NewFromFasthttp(ctx, &response.Options{
		ServiceName: w.ServiceName,
	})

	// Common attributes to print in each log message inside the handler.
	logAttributes := map[string]interface{}{
		"request.endpoint":  string(ctx.RequestURI()),
		"request.client_ip": ctx.RemoteIP(),
		"request.method":    string(ctx.Method()),
	}

	w.Logger.Infof(ctx, "request received", logAttributes)

	if w.AuthHandler != nil {
		if err := w.AuthHandler(ctx); err != nil {
			_ = res.ForwardAuthenticationError(err)
			logAttributes["error.message"] = err.Error()
			w.Logger.Errorf(ctx, "authentication error", logAttributes)
			return
		}
	}

	input, err := newGetProductByIDRequestFromFasthttpRequest(ctx)
	if err != nil {
		_ = res.ForwardError(err)
		logAttributes["error.message"] = err.Error()
		w.Logger.Errorf(ctx, "request input error", logAttributes)
		return
	}

	out, err := w.Handler.GetProductByID(ctx, input.ProtoResponse())
	if err != nil {
		_ = res.ForwardError(err)

		// Just a warning here. We don't need to log the error message
		// here simply because the error returned by the handler should
		// use the framework.Error API which already writes a message
		// into it.
		return
	}

	w.Logger.Infof(ctx, "request successfully handled", logAttributes)
	_ = res.ForwardSuccess(out)
}

//
// ///////////////////// GetProductByID //////////////////////
//

// newGetProductByIDRequestFromFasthttpRequest creates a GetProductByIDRequest object by filling it with values
// from the request data. It handles all possible arguments here: path, query
// and body.
func newGetProductByIDRequestFromFasthttpRequest(ctx *fasthttp.RequestCtx) (*GetProductByIDRequestModel, error) {
	g := &GetProductByIDRequestModel{}

	// Starts by parsing the request body into the whole structure. If we have
	// a field that's not in the body and the user passes it here with a wrong
	// JSON value, it will return an error.
	//
	// Then we parse all other fields from different location, if needed. Like
	// path, query or header parameters. And, before parsing each one of them,
	// we zero them to make sure that they are uninitialized.

	response.Zero(&g.Id)
	if v, ok := ctx.UserValue("id").(string); ok {
		g.Id = v
	}

	queryArgs := ctx.QueryArgs()

	response.Zero(&g.ReturnDeleted)
	if value := queryArgs.Peek("return_deleted"); value != nil {
		if err := response.Decode(value, &g.ReturnDeleted); err != nil {
			return nil, fmt.Errorf("return_deleted@query: %w", err)
		}
	}

	return g, nil
}

func (w *fasthttpServerRoutesWrapper) UpdateProduct(ctx *fasthttp.RequestCtx) {
	res := response.NewFromFasthttp(ctx, &response.Options{
		ServiceName: w.ServiceName,
	})

	// Common attributes to print in each log message inside the handler.
	logAttributes := map[string]interface{}{
		"request.endpoint":  string(ctx.RequestURI()),
		"request.client_ip": ctx.RemoteIP(),
		"request.method":    string(ctx.Method()),
	}

	w.Logger.Infof(ctx, "request received", logAttributes)

	if w.AuthHandler != nil {
		if err := w.AuthHandler(ctx); err != nil {
			_ = res.ForwardAuthenticationError(err)
			logAttributes["error.message"] = err.Error()
			w.Logger.Errorf(ctx, "authentication error", logAttributes)
			return
		}
	}

	input, err := newUpdateProductRequestFromFasthttpRequest(ctx)
	if err != nil {
		_ = res.ForwardError(err)
		logAttributes["error.message"] = err.Error()
		w.Logger.Errorf(ctx, "request input error", logAttributes)
		return
	}

	out, err := w.Handler.UpdateProduct(ctx, input.ProtoResponse())
	if err != nil {
		_ = res.ForwardError(err)

		// Just a warning here. We don't need to log the error message
		// here simply because the error returned by the handler should
		// use the framework.Error API which already writes a message
		// into it.
		return
	}

	w.Logger.Infof(ctx, "request successfully handled", logAttributes)
	_ = res.ForwardSuccess(out)
}

//
// ///////////////////// UpdateProduct //////////////////////
//

// newUpdateProductRequestFromFasthttpRequest creates a UpdateProductRequest object by filling it with values
// from the request data. It handles all possible arguments here: path, query
// and body.
func newUpdateProductRequestFromFasthttpRequest(ctx *fasthttp.RequestCtx) (*UpdateProductRequestModel, error) {
	u := &UpdateProductRequestModel{}

	// Starts by parsing the request body into the whole structure. If we have
	// a field that's not in the body and the user passes it here with a wrong
	// JSON value, it will return an error.
	//
	// Then we parse all other fields from different location, if needed. Like
	// path, query or header parameters. And, before parsing each one of them,
	// we zero them to make sure that they are uninitialized.

	if len(ctx.PostBody()) == 0 {
		return nil, errors.New(emptyBodyError)
	}

	if err := json.Unmarshal(ctx.PostBody(), u); err != nil {
		return nil, fmt.Errorf("body: %w", err)
	}

	response.Zero(&u.Id)
	if v, ok := ctx.UserValue("id").(string); ok {
		u.Id = v
	}

	return u, nil
}

func (w *fasthttpServerRoutesWrapper) DeleteProduct(ctx *fasthttp.RequestCtx) {
	res := response.NewFromFasthttp(ctx, &response.Options{
		ServiceName: w.ServiceName,
	})

	// Common attributes to print in each log message inside the handler.
	logAttributes := map[string]interface{}{
		"request.endpoint":  string(ctx.RequestURI()),
		"request.client_ip": ctx.RemoteIP(),
		"request.method":    string(ctx.Method()),
	}

	w.Logger.Infof(ctx, "request received", logAttributes)

	if w.AuthHandler != nil {
		if err := w.AuthHandler(ctx); err != nil {
			_ = res.ForwardAuthenticationError(err)
			logAttributes["error.message"] = err.Error()
			w.Logger.Errorf(ctx, "authentication error", logAttributes)
			return
		}
	}

	input, err := newDeleteProductRequestFromFasthttpRequest(ctx)
	if err != nil {
		_ = res.ForwardError(err)
		logAttributes["error.message"] = err.Error()
		w.Logger.Errorf(ctx, "request input error", logAttributes)
		return
	}

	out, err := w.Handler.DeleteProduct(ctx, input.ProtoResponse())
	if err != nil {
		_ = res.ForwardError(err)

		// Just a warning here. We don't need to log the error message
		// here simply because the error returned by the handler should
		// use the framework.Error API which already writes a message
		// into it.
		return
	}

	w.Logger.Infof(ctx, "request successfully handled", logAttributes)
	_ = res.ForwardSuccess(out)
}

//
// ///////////////////// DeleteProduct //////////////////////
//

// newDeleteProductRequestFromFasthttpRequest creates a DeleteProductRequest object by filling it with values
// from the request data. It handles all possible arguments here: path, query
// and body.
func newDeleteProductRequestFromFasthttpRequest(ctx *fasthttp.RequestCtx) (*DeleteProductRequestModel, error) {
	d := &DeleteProductRequestModel{}

	// Starts by parsing the request body into the whole structure. If we have
	// a field that's not in the body and the user passes it here with a wrong
	// JSON value, it will return an error.
	//
	// Then we parse all other fields from different location, if needed. Like
	// path, query or header parameters. And, before parsing each one of them,
	// we zero them to make sure that they are uninitialized.

	response.Zero(&d.Id)
	if v, ok := ctx.UserValue("id").(string); ok {
		d.Id = v
	}

	return d, nil
}
