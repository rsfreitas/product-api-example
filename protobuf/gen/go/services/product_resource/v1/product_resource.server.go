// Code generated by protoc-gen-fasthttp. DO NOT EDIT.
package product_resourcev1

import (
	"context"
	"errors"
	"fmt"
	"net"
	"time"
	"os"
	"os/signal"
	"syscall"

	"github.com/fasthttp/router"
	"github.com/valyala/fasthttp"
	"github.com/labstack/echo/v4"
)

type ServerKind int

const (
	FasthttpServer ServerKind = iota
	EchoServer
)

// Logger is the internal server log interface that the service must have
// implemented.
type Logger interface {
	Infof(ctx context.Context, msg string, attrs ...map[string]interface{})
	Errorf(ctx context.Context, msg string, attrs ...map[string]interface{})
}

// AuthHandler is the authentication function that a server must implement, if
// using authenticated routes, in order to validate the user access to the route.
// Inside this handler the user can access the request Context, reading or
// updating it.
type AuthHandler func(ctx context.Context, scopes ...string) error

// HttpResponser is an interface that a response kind message implements to be
// able to make conversions between types and formats of its members.
type HttpResponser interface {
	HttpResponse() interface{}
}

type HttpServer struct {
	port       int
	serverKind ServerKind
	handler    *HttpServerHandler
	listener   net.Listener
	server     *fasthttp.Server
	echoServer *echo.Echo
	logger     Logger
}

// HttpServerHandler is the framework handler for manipulating and accessing
// its features.
type HttpServerHandler struct {
	wrapper     *fasthttpServerRoutesWrapper
	echoWrapper *echoServerRoutesWrapper
}

type HttpServerOptions struct {
	Port        int
	ServerKind  ServerKind
	Logger      interface{}
	ServiceName string
	ApiHandlers interface{}
	AuthHandler func(ctx context.Context, scopes ...string) error
}

// NewHttpServer creates the main HTTP service object.
func NewHttpServer(options *HttpServerOptions) (*HttpServer, error) {
	handlers, ok := options.ApiHandlers.(ProductResourceServiceServer)
	if !ok {
		return nil, errors.New("cannot convert apiHandlers to the service proper type")
	}

	log, ok := options.Logger.(Logger)
	if !ok {
		return nil, errors.New("could not retrieve internal logger interface")
	}

	server := &HttpServer{
		port:       options.Port,
		logger:     log,
		serverKind: options.ServerKind,
		handler: &HttpServerHandler{
			wrapper: &fasthttpServerRoutesWrapper{
				Handler:     handlers,
				ServiceName: options.ServiceName,
				Logger:      log,
				AuthHandler: options.AuthHandler,
			},
			echoWrapper: &echoServerRoutesWrapper{
				Handler:     handlers,
				ServiceName: options.ServiceName,
				Logger:      log,
				AuthHandler: options.AuthHandler,
			},
		},
	}

	if options.ServerKind == FasthttpServer {
		listener, err := net.Listen("tcp", fmt.Sprintf(":%d", options.Port))
		if err != nil {
			return nil, fmt.Errorf("could not listen to service port: %w", err)
		}

		router := router.New()

		router.Handle("POST", "/product-resource/v1/products", server.handler.wrapper.CreateProduct)
		router.Handle("GET", "/product-resource/v1/products/{id}", server.handler.wrapper.GetProductByID)
		router.Handle("PUT", "/product-resource/v1/products/{id}", server.handler.wrapper.UpdateProduct)
		router.Handle("DELETE", "/product-resource/v1/products/{id}", server.handler.wrapper.DeleteProduct)

		server.listener = listener
		server.server = registerHttpServer(router.Handler)
	}

	if options.ServerKind == EchoServer {
		e := echo.New()

		e.POST("/product-resource/v1/products", server.handler.echoWrapper.CreateProduct)
		e.GET("/product-resource/v1/products/:id", server.handler.echoWrapper.GetProductByID)
		e.PUT("/product-resource/v1/products/:id", server.handler.echoWrapper.UpdateProduct)
		e.DELETE("/product-resource/v1/products/:id", server.handler.echoWrapper.DeleteProduct)

		server.echoServer = e
	}

	return server, nil
}

func registerHttpServer(handler fasthttp.RequestHandler) *fasthttp.Server {
	handler = serverRequestHandler(handler)
	return &fasthttp.Server{
		NoDefaultServerHeader: true,
		Handler:               handler,
		ErrorHandler:          handleHTTPError,
		ReadTimeout:           60 * time.Second,
		WriteTimeout:          60 * time.Second,
		ReadBufferSize:        64 * 1024,
		WriteBufferSize:       64 * 1024,
	}
}

func serverRequestHandler(h fasthttp.RequestHandler) fasthttp.RequestHandler {
	return func(ctx *fasthttp.RequestCtx) {
		if ctx.IsGet() && string(ctx.Path()) == "/health" {
			ctx.SetStatusCode(fasthttp.StatusOK)
			return
		}

		h(ctx)
	}
}

func handleHTTPError(ctx *fasthttp.RequestCtx, err error) {
	fmt.Println("http error", err.Error())
}

func (h *HttpServer) Run() {
	ctx := context.Background()
	defer h.stop(ctx)

	errChan := make(chan error)
	stopChan := make(chan os.Signal, 1)
	signal.Notify(stopChan, syscall.SIGTERM, syscall.SIGINT)
	h.logger.Infof(ctx, "service is running")

	go func() {
		if h.serverKind == FasthttpServer {
			if err := h.server.Serve(h.listener); err != nil {
				errChan <- err
			}
		}

		if h.serverKind == EchoServer {
			if err := h.echoServer.Start(fmt.Sprintf(":%v", h.port)); err != nil {
				errChan <- err
			}
		}
	}()

	// Blocks the call
	select {
	case err := <-errChan:
		h.logger.Errorf(ctx, "fatal error", map[string]interface{}{
			"error.message": err.Error(),
		})

	case <-stopChan:
	}
}

func (h *HttpServer) stop(ctx context.Context) error {
	h.logger.Infof(ctx, "service finished")

	if h.serverKind == FasthttpServer {
		return h.server.Shutdown()
	}

	if h.serverKind == EchoServer {
		return h.echoServer.Shutdown(ctx)
	}

	return nil
}
